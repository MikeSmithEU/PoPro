{"name":"Popro","tagline":"The Poor-Man's Progress Indicator","body":"# Po'Pro: The Poor-Man's Progress Indicator\r\n\r\n[![Version](https://badge.fury.io/rb/popro.svg)](https://badge.fury.io/rb/popro) \r\n[![Tests](https://github.com/MikeSmithEU/PoPro/workflows/Code%20quality%20&%20unit%20tests/badge.svg)](https://github.com/MikeSmithEU/PoPro/actions?query=workflow%3A%22Code+quality+%26+unit+tests%22)\r\n\r\n## Current TODOs\r\n\r\n - [ ] properly update documentation\r\n - [ ] simplify some stuff (each0?)\r\n - [ ] 100% code coverage\r\n\r\n## Why?\r\n\r\nEasier and cleaner progress indication.\r\n\r\n## How?\r\n\r\n### Basic usage\r\n\r\nThe invocation `Popro#did(yielded)` is used to signify that one step in progress has been finished.\r\n\r\n1. Create a `Progress` object\r\n   ```ruby\r\n   progress = Popro.new(500)\r\n   ```\r\n\r\n2. Use the progress indicator\r\n  ```ruby\r\n  (0..499).each { progress.did }\r\n  ```\r\n\r\n  Will result in a default progress outputted to STDOUT, e.g.\r\n\r\n  ```bash\r\n  irb> (0..499).each { |n| sleep(0.1) & \"Just did #{n}\" }\r\n  [221/500] 44.2% Just did 220\r\n  ```\r\n\r\n  Note, `Popro#did` can be passed as a `Proc` using the shortcut `&progress`.\r\n  So below code would be equivalent and slightly more concise:\r\n\r\n  ```ruby\r\n  (0.499).each &progress\r\n  ```\r\n\r\nBlock notation is usually preferable (cleaner) to using the `Progress` instance directly (see below).\r\nThe functionality is the same though.\r\n\r\n### Using block context\r\n\r\n`Popro.new` can be called with a block. This block will then be executed after `Progress` has initialized\r\nand will receive a `Context` instance as the first parameter.  On this instance you can call e.g.\r\n`each`, `did`, `will` and `formatter`.\r\n\r\nE.g.\r\n\r\n```ruby\r\nPopro.new(500) do |p|\r\n  (1..500).each &p\r\nend\r\n```\r\n\r\nor\r\n\r\n```ruby\r\nPopro.new do |progress|\r\n  progress.each(1..500)\r\nend\r\n```\r\n\r\n### Using `Proc` shortcut notation\r\n\r\n`&Popro.new`  can be used for a more concise syntax. This is just syntactical sugar for calling\r\n`Popro#did` directly.\r\n\r\nFor example:\r\n\r\n```ruby\r\ndef job(size=100)\r\n  (1..size).each do\r\n    sleep 0.01\r\n    yield\r\n  end\r\nend\r\n\r\n# Below invocations are all equivalent.\r\n\r\nputs \"\\n job(&progress)\"\r\nprogress = Popro.new(100)\r\njob(&progress)\r\n\r\nputs \"\\n job { progress.did }\"\r\nprogress = Popro.new(100)\r\njob { progress.did }\r\n\r\nputs \"\\n using Popro.new(100)\"\r\n\r\n# below code is a more concise equivalent to:\r\n#   `progress = Popro.new(100); job &progress`\r\n# or\r\n#   `progress = Popro.new(100); job { |*args| progress.did(*args) }`\r\n\r\njob(&Popro.new(100))\r\n```\r\n\r\n### Using each notation\r\n\r\n`Popro.each` or `Popro#each` can be used to loop over enumerables while providing progress\r\nfeedback.\r\n\r\n`Popro.each(enumerable, size=nil)` will use `enumerable.size` to determine the total amount of elements\r\nonly if the `size` argument is `nil`.\r\nIf this method is not available you should manually provide a `size` argument, i.e.  `Popro.each(enumerable, 50)`.\r\n\r\nShortcut methods `Popro.each0(enumerable)` and `Popro#each0(enumerable)` are available for enumerables\r\nthat are used if you do not want to update the total with `enumerable.size`.\r\nI.e. this is equivalent to `Popro.each(enumerable, 0)` and `Popro#each(enumerable, 0)` respectively.\r\n\r\nE.g. below are all equivalent.\r\n\r\n```ruby\r\nsleeper = proc { sleep 0.05 }\r\n\r\nPopro.each(1..50) { sleep 0.05 }\r\nPopro.new.each(1..50, 50) { sleep 0.05 }\r\nPopro.new(50).each(1..50, 0) { sleep 0.05 }\r\nPopro.new(50).each0(1..50) { sleep 0.05 }\r\n\r\nPopro.each(1..50, &sleeper)\r\nPopro.new(50).each(1..50, 0, &sleeper)\r\nPopro.new(50).each0(1..50, &sleeper)\r\n\r\nPopro.each(1..50, 50, &sleeper)\r\nPopro.new.each(1..50, 50, &sleeper)\r\n```\r\n\r\nIt is easy to chain multiple items, the total will be updated at the start of each `each` block. It\r\nmight be preferable to provide a total sum in advance, and passing a `size` argument of `0` to\r\n`Popro#each` (or using `Popro#each0`), e.g.\r\n\r\n```ruby\r\n\r\nPopro.new(200)\r\n  .each0(1..50) { |n| sleep(0.1) && \"#{n} of first 50\" }\r\n  .each0(1..100) { |n| sleep(0.1) && \"#{n} of second 100\" }\r\n  .each0(1..50) { |n| sleep(0.1) && \"#{n} of last 50\" }\r\n\r\n```\r\n\r\nOr, using a block:\r\n\r\n```ruby\r\n\r\nPopro.new(200) do |p|\r\n  p.each0(1..50) { |n| sleep(0.1) && \"#{n} of first 50\" }\r\n  p.each0(1..100) { |n| sleep(0.1) && \"#{n} of second 100\" }\r\n  p.each0(1..50) { |n| sleep(0.1) && \"#{n} of last 50\" }\r\nend\r\n\r\n```\r\n\r\nNote that when using `Popro.each(enumberable, &block)` or `Popro#each(enumerable, &block)` the arguments\r\npassed to `block` on invocation are not the same as for `Popro.new`.\r\n\r\n`Popro.each` invokes `enumerable.each` and the argument signature of the `Popro.each` `&block` is the\r\nsame as the signature that `enumerable.each` uses to call the block. Only the named argument `progress` is\r\nadded (as opposed to being the first argument as for `Popro.new`).\r\n\r\nE.g.\r\n\r\n```ruby\r\n\r\nPopro.each(1..100) do |number, progress:|\r\n  progress.will \"count sheep ##{number} and sleep for a bit\" do\r\n    sleep 0.1\r\n  end\r\nend\r\n\r\n```\r\n\r\nwould be equivalent to:\r\n\r\n```ruby\r\n\r\nPopro.new(100) do |p|\r\n  p.each(1..100) do |number, progress:|\r\n    # note, `p == progress`, only added `progress:` to `each` call for example purposes\r\n    p.will \"count sheep ##{number} and sleep for a bit\" do\r\n      sleep 0.1\r\n    end\r\n  end\r\nend\r\n\r\n```\r\n\r\n### Using `Popro#will`\r\n\r\nThe helper `Popro#will(message, &block)` can be used to signify intention. When given a block, it will mark\r\nthis intention as done when the block has finished (using a call to `Popro#did`). If no block is passed,\r\n`Popro#did` needs to be invoked manually once the intention has been fulfilled.\r\n\r\nThis method sends the `message` passed to `Popro#will` to the `Indicator` so it can handle it (usually output to\r\nscreen).\r\n\r\nThus `Popro#will` can be used to signify the action about to take place instead of the action that has just finished.\r\nIf the script encounters some kind of error, we can now see in which context this error occured instead of seeing\r\nthe last invocation that did not cause an error.\r\n\r\nE.g.\r\n\r\n```ruby\r\nPopro.each(1..200) do |progress:|\r\n  progress.will \"sleep a bit\" do\r\n    sleep 0.1\r\n  end\r\nend\r\n\r\n# equivalent to\r\n\r\nPopro.new(200) do |p|\r\n  200.times do\r\n    p.will \"sleep a bit\" do\r\n      sleep 0.01\r\n    end\r\n  end\r\nend\r\n\r\n# equivalent to\r\n\r\nPopro.new(200) do |p|\r\n  200.times do\r\n    p.will \"sleep a bit\"\r\n    sleep 0.01\r\n    p.done \"sleep a bit: DONE\"\r\n  end\r\nend\r\n```\r\n\r\n### Using `Popro.each_will`\r\n\r\n`Popro.each_will(enumerator, titler, size = nil, &block)` is a shortcut for:\r\n\r\n```ruby\r\nPopro.each(enumerator, size) do |*args, **kwargs, progress:|\r\n  progress.will titler.call(*args) do\r\n    block.call(*args, **kwargs)\r\n  end\r\nend\r\n```\r\n\r\nSo instead of e.g.\r\n\r\n```ruby\r\nPopro.each(SomeModel.all) do |model, progress:|\r\n  progress.will \"Delete #{model.id}\" do\r\n    model.destroy\r\n  end\r\nend\r\n```\r\n\r\nA more concise syntax is available:\r\n\r\n```ruby\r\ntitler = ->(model) { \"Delete #{model.id}\" }\r\nPopro.each_will(SomeModel.all, titler) do |model|\r\n  model.destroy\r\nend\r\n```\r\n\r\n## Formatters\r\n\r\nYou can set your own formatters using `Popro#formatter(&block)`. Each formatter can be a `Proc`, `block` or\r\nclass implementing the `call` method (e.g. the `Popro::Formatter::*` classes).\r\n\r\nThe formatter will be invoked with 2 arguments:\r\n\r\n  1. `info`, an instance of `Popro::Info` containing e.g. `current` and `total`.\r\n  2. `yielded`, whatever was passed to the `Popro#did` method.\r\n\r\nIt can also be used inside blocks.\r\n\r\nE.g.\r\n\r\n```ruby\r\n\r\nprogress = Popro.new\r\nprogress.formatter do |info, yielded|\r\n  \"#{info.current}, yielded #{yielded}\\n\"\r\nend\r\nprogress.each(1..8) { |i| i**2 }\r\nprogress.formatter { \".\" } # output a dot\r\nprogress.each(1..8) { |i| i**2 }\r\n\r\n# or equivalent, more concise:\r\n\r\nPopro.new do |p|\r\n  p.formatter { |info, yielded| \"#{info.current}, yielded #{yielded}\\n\" }\r\n  p.each(1..8) { |i| i**2 }\r\n\r\n  p.formatter { \".\" } # output a dot\r\n  p.each(1..8) { |i| i**2 }\r\nend\r\n\r\n```\r\n\r\nwould output:\r\n\r\n```\r\n 1, yielded 1\r\n 2, yielded 4\r\n 3, yielded 9\r\n 4, yielded 16\r\n 5, yielded 25\r\n 6, yielded 36\r\n 7, yielded 49\r\n 8, yielded 64\r\n ........\r\n```\r\n\r\n\r\n## Indicator Classes\r\n\r\nIndicator classes are responsible for communicating the progress (or not, as the case may be).\r\n\r\nIt is possible to provide your own \"indicators\" or use one of the provided ones (see `Popro::Indicator` module).\r\n\r\nThe default `Popro::Indicator` class is `Popro::Indicator.default` (which returns an instance of `Popro::Indicator::Stream`), which outputs the progress to STDOUT each time `Popro#did` or `Popro#will` is called.\r\n\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}